// Emergency Model Number Correction System
// Fixes inaccurate Mercury model numbers and prevents future corruption

import { supabase } from '@/integrations/supabase/client';
import { getCorrectModelNumber, getAllModelMappings, isValidModelNumber } from './mercury-model-number-mapping';
import { validateMotorModel } from './motor-model-validation';
import { formatMotorDisplayName } from './motor-display-formatter';

export interface CorrectionResult {
  motorsProcessed: number;
  motorsDeleted: number;
  motorsCorrected: number;
  errors: string[];
  warnings: string[];
  details: any[];
}

/**
 * Emergency correction function to fix model numbers and remove duplicates
 * Uses official Mercury reference to validate and correct all motor data
 */
export async function emergencyModelCorrection(): Promise<CorrectionResult> {
  const result: CorrectionResult = {
    motorsProcessed: 0,
    motorsDeleted: 0,
    motorsCorrected: 0,
    errors: [],
    warnings: [],
    details: []
  };

  try {
    console.log('üö® EMERGENCY MODEL CORRECTION STARTING...');
    console.log('üìã Using official Mercury reference with 167 models');

    // 1. Get all brochure motors
    const { data: brochureMotors, error: fetchError } = await supabase
      .from('motor_models')
      .select('*')
      .eq('is_brochure', true)
      .order('horsepower', { ascending: true });

    if (fetchError) {
      result.errors.push(`Failed to fetch brochure motors: ${fetchError.message}`);
      return result;
    }

    if (!brochureMotors) {
      result.errors.push('No brochure motors found');
      return result;
    }

    result.motorsProcessed = brochureMotors.length;
    console.log(`üìä Found ${brochureMotors.length} brochure motors to process`);

    // 2. Identify invalid motors (auto-generated, duplicates, incorrect model numbers)
    const validMotors: any[] = [];
    const motorsToDelete: any[] = [];
    const officialModelNumbers = getAllModelMappings().map(m => m.modelNumber);

    for (const motor of brochureMotors) {
      const isAutoGenerated = motor.model_number?.match(/^[0-9.]+[A-Z]+-[A-Z]+-202[0-9]/);
      const hasSuffix = motor.model_number?.includes('-') && !officialModelNumbers.includes(motor.model_number);
      const isInvalidOfficial = motor.model_number && !isValidModelNumber(motor.model_number) && !isAutoGenerated;
      
      if (isAutoGenerated || hasSuffix || isInvalidOfficial) {
        motorsToDelete.push(motor);
        console.log(`üóëÔ∏è Marking for deletion: ${motor.model_number} (${motor.model_display}) - ${isAutoGenerated ? 'auto-generated' : hasSuffix ? 'has suffix' : 'invalid official'}`);
      } else {
        validMotors.push(motor);
      }
    }

    // 3. Delete all invalid motors first
    console.log(`\nüßπ Deleting ${motorsToDelete.length} invalid motors...`);
    for (const motor of motorsToDelete) {
      const { error: deleteError } = await supabase
        .from('motor_models')
        .delete()
        .eq('id', motor.id);

      if (deleteError) {
        result.errors.push(`Failed to delete motor ${motor.id}: ${deleteError.message}`);
      } else {
        result.motorsDeleted++;
        result.details.push({
          action: 'deleted',
          id: motor.id,
          modelNumber: motor.model_number,
          reason: 'invalid/auto-generated/duplicate'
        });
      }
    }

    // 4. Group remaining valid motors by HP and rigging code for duplicate detection
    const motorGroups = new Map<string, any[]>();
    
    for (const motor of validMotors) {
      // Create key from HP and rigging code extracted from display name
      const hp = motor.horsepower || 0;
      const displayName = motor.model_display || '';
      const riggingMatch = displayName.match(/(\b(?:MH|MLH|MXLH|EH|ELH|EL|EPT|ELPT|EXLPT|ELHPT|EXLHPT|L|XL|CXL|XXL|CXXL|CT|DTS|MRC|MLHA|MHGA|MLHGA|ELGA|ELHGA|ECXLPT|EXLH)\b)/i);
      const rigging = riggingMatch ? riggingMatch[1].toUpperCase() : 'UNKNOWN';
      const family = motor.family || (displayName.includes('Pro XS') ? 'ProXS' : 'FourStroke');
      
      const key = `${hp}-${rigging}-${family}`;
      if (!motorGroups.has(key)) {
        motorGroups.set(key, []);
      }
      motorGroups.get(key)!.push(motor);
    }

    // 5. Process groups - keep best motor, delete duplicates
    for (const [groupKey, motors] of motorGroups) {
      console.log(`\nüîç Processing group: ${groupKey} (${motors.length} motors)`);
      
      if (motors.length === 1) {
        // Single motor - validate and correct if needed
        await processSingleMotor(motors[0], result);
      } else {
        // Multiple motors - remove duplicates and fix the remaining one
        await processDuplicateMotors(motors, result);
      }
    }

    console.log('\n‚úÖ EMERGENCY CORRECTION COMPLETE');
    console.log(`üìà Summary: ${result.motorsCorrected} corrected, ${result.motorsDeleted} deleted`);

    return result;

  } catch (error) {
    console.error('‚ùå Emergency correction failed:', error);
    result.errors.push(`Critical error: ${error instanceof Error ? error.message : 'Unknown error'}`);
    return result;
  }
}

/**
 * Process a single motor for validation and correction
 */
async function processSingleMotor(motor: any, result: CorrectionResult) {
  const displayName = motor.model_display || motor.model || '';
  const validation = validateMotorModel(displayName, motor.model_number);
  
  if (!validation.isValid && validation.correctedModelNumber) {
    console.log(`üîß Correcting ${motor.id}: ${motor.model_number} ‚Üí ${validation.correctedModelNumber}`);
    
    // Update with correct model number and display name
    const { error: updateError } = await supabase
      .from('motor_models')
      .update({
        model_number: validation.correctedModelNumber,
        model_display: formatMotorDisplayName(displayName),
        updated_at: new Date().toISOString()
      })
      .eq('id', motor.id);

    if (updateError) {
      result.errors.push(`Failed to update motor ${motor.id}: ${updateError.message}`);
    } else {
      result.motorsCorrected++;
      result.details.push({
        action: 'corrected',
        id: motor.id,
        oldModelNumber: motor.model_number,
        newModelNumber: validation.correctedModelNumber,
        displayName: formatMotorDisplayName(displayName)
      });
    }
  } else if (validation.isValid) {
    // Just fix display name formatting if needed
    const formattedDisplay = formatMotorDisplayName(displayName);
    if (formattedDisplay !== motor.model_display) {
      const { error: updateError } = await supabase
        .from('motor_models')
        .update({
          model_display: formattedDisplay,
          updated_at: new Date().toISOString()
        })
        .eq('id', motor.id);

      if (!updateError) {
        result.motorsCorrected++;
        result.details.push({
          action: 'display_fixed',
          id: motor.id,
          oldDisplay: motor.model_display,
          newDisplay: formattedDisplay
        });
      }
    }
  }
}

/**
 * Process duplicate motors - keep the best one, delete the rest
 */
async function processDuplicateMotors(motors: any[], result: CorrectionResult) {
  console.log(`üî• Found ${motors.length} duplicate motors`);
  
  // Find the best motor to keep (official model number, no suffix)
  let bestMotor = null;
  const motorsToDelete = [];

  for (const motor of motors) {
    const hasOfficialModelNumber = isValidModelNumber(motor.model_number) && !motor.model_number.includes('-');
    
    if (hasOfficialModelNumber && !bestMotor) {
      bestMotor = motor;
    } else {
      motorsToDelete.push(motor);
    }
  }

  // If no motor has official model number, keep the first one and fix it
  if (!bestMotor) {
    bestMotor = motors[0];
    motorsToDelete.splice(0, 1); // Remove it from delete list
  }

  // Delete duplicate motors
  for (const motor of motorsToDelete) {
    console.log(`üóëÔ∏è Deleting duplicate: ${motor.id} (${motor.model_number})`);
    
    const { error: deleteError } = await supabase
      .from('motor_models')
      .delete()
      .eq('id', motor.id);

    if (deleteError) {
      result.errors.push(`Failed to delete motor ${motor.id}: ${deleteError.message}`);
    } else {
      result.motorsDeleted++;
      result.details.push({
        action: 'deleted',
        id: motor.id,
        modelNumber: motor.model_number,
        reason: 'duplicate'
      });
    }
  }

  // Fix the remaining motor
  if (bestMotor) {
    await processSingleMotor(bestMotor, result);
  }
}

/**
 * Add protection trigger to prevent future model number corruption
 */
export async function addModelNumberProtection(): Promise<void> {
  console.log('üîí Adding model number protection...');
  
  // This would be implemented as a database function/trigger
  // For now, we'll add validation in the application layer
  console.log('‚ö†Ô∏è Model number protection should be implemented at database level');
}

/**
 * Validate all current brochure motors against Mercury reference
 */
/**
 * NUCLEAR OPTION: Complete database wipe and rebuild
 * Deletes ALL brochure motors and rebuilds from official Mercury reference only
 */
export async function nuclearRebuildFromOfficial(): Promise<CorrectionResult> {
  const result: CorrectionResult = {
    motorsProcessed: 0,
    motorsDeleted: 0,
    motorsCorrected: 0,
    errors: [],
    warnings: [],
    details: []
  };

  try {
    console.log('üí• NUCLEAR OPTION: Complete database wipe and rebuild starting...');
    
    // Step 1: Get count of current brochure motors
    const { count: currentCount, error: countError } = await supabase
      .from('motor_models')
      .select('*', { count: 'exact', head: true })
      .eq('is_brochure', true);

    if (countError) {
      result.errors.push(`Failed to count existing motors: ${countError.message}`);
      return result;
    }

    console.log(`üóëÔ∏è Found ${currentCount} existing brochure motors to delete`);
    
    // Step 2: COMPLETE WIPE - Delete ALL brochure motors
    const { error: wipeError } = await supabase
      .from('motor_models')
      .delete()
      .eq('is_brochure', true);

    if (wipeError) {
      result.errors.push(`Failed to wipe database: ${wipeError.message}`);
      return result;
    }

    result.motorsDeleted = currentCount || 0;
    console.log(`‚úÖ Successfully deleted ${result.motorsDeleted} motors`);

    // Step 3: Rebuild from official Mercury reference (167 models)
    const officialModels = getAllModelMappings();
    console.log(`üì¶ Rebuilding with ${officialModels.length} official Mercury models...`);

    let insertedCount = 0;
    
    for (const model of officialModels) {
      try {
        // Convert official model to database format
        const motorData = {
          model_number: model.modelNumber,
          model_display: model.description,
          horsepower: model.hp,
          family: model.family,
          rigging_code: model.riggingCode,
          motor_type: 'Outboard',
          model: 'Outboard',
          make: 'Mercury',
          year: 2025,
          is_brochure: true,
          model_key: `MERCURY_${model.modelNumber}_${model.hp}HP`,
          mercury_model_no: model.modelNumber,
          dealer_price: 0, // Will be updated by pricing sync
          msrp: 0, // Will be updated by pricing sync
          created_at: new Date().toISOString(),
          updated_at: new Date().toISOString()
        };

        const { error: insertError } = await supabase
          .from('motor_models')
          .insert(motorData);

        if (insertError) {
          result.errors.push(`Failed to insert ${model.modelNumber}: ${insertError.message}`);
        } else {
          insertedCount++;
          result.details.push({
            action: 'inserted',
            modelNumber: model.modelNumber,
            reason: 'official rebuild'
          });
        }
      } catch (error) {
        result.errors.push(`Error processing ${model.modelNumber}: ${error}`);
      }
    }

    result.motorsProcessed = officialModels.length;
    result.motorsCorrected = insertedCount;
    
    console.log(`‚úÖ Nuclear rebuild complete!`);
    console.log(`üìä Motors deleted: ${result.motorsDeleted}`);
    console.log(`üìä Motors inserted: ${insertedCount}`);
    console.log(`üìä Expected: ${officialModels.length}`);
    
    if (insertedCount === officialModels.length) {
      console.log('üéâ Perfect rebuild - all official models inserted!');
    } else {
      result.warnings.push(`Expected ${officialModels.length} motors, got ${insertedCount}`);
    }

  } catch (error) {
    console.error('Nuclear rebuild failed:', error);
    result.errors.push(`Nuclear rebuild failed: ${error}`);
  }

  return result;
}

export async function validateAllMotors(): Promise<{ valid: number; invalid: number; issues: string[] }> {
  const issues: string[] = [];
  let valid = 0;
  let invalid = 0;

  const { data: motors, error } = await supabase
    .from('motor_models')
    .select('id, model_number, model_display, horsepower, family')
    .eq('is_brochure', true);

  if (error || !motors) {
    issues.push('Failed to fetch motors for validation');
    return { valid: 0, invalid: 0, issues };
  }

  for (const motor of motors) {
    const validation = validateMotorModel(motor.model_display || '', motor.model_number);
    
    if (validation.isValid) {
      valid++;
    } else {
      invalid++;
      issues.push(`${motor.horsepower}HP: ${validation.issues.join(', ')}`);
    }
  }

  return { valid, invalid, issues };
}
